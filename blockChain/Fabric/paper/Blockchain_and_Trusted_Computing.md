### 1 INTRODUCTION 

Blockchain and distributed ledger technology (DLT) have received a lot of attention recently as means to distribute trust over many nodes in a network. The transparency and resilience gained from the decentralized protocol execution ensure the integrity of blockchain applications, or smart contracts, realized on such a “world computer.” However, the proliferation of data on a blockchain directly contradicts the goal to keep the application state confidential and to maintain privacy for its users, a condition that exists for many intended applications of blockchain technology. 

Although cryptographic protocols (such as secure multiparty computation and zero-knowledge proofs) offer attractive solutions for privacy on a blockchain, they are not yet mature enough to run general-purpose computations easily and to be widely deployed. As a `promising alternative`, the use of trusted execution environments (TEEs) for running blockchain applications has been proposed, especially by the industry working on consortium blockchains, where the consensus process is governed by controlled nodes [17, 32]. `Intel`’s 

Software Guard Extensions (SGX) is the most prominent TEE technology today and available together with commodity CPUs [2, 18, 31]. It establishes `trusted execution contexts` called `enclaves` on a CPU, which isolate data and programs from the host operating system in hardware and ensure that outputs are correct. An enclave might run only a small dedicated part of an application [11, 18, 29] or can contain an entire legacy system, including some operating-system support [5, 7, 44]. By using a TEE, one does not have to trust the host system of the enclave, which runs the blockchain node and participates in protocols. 

For protecting smart contracts through TEEs, issues around roll- back attacks, state continuity, and protocol integration for TEEs [42] must be addressed. As is well-known, there are non-trivial inter- actions between integrity violations and information leakage for stateful secure computation [1]. 

Motivating example. Imagine an auction of a digital item on a blockchain. In sealed-bid auction designs [34] (e.g., Vickrey auctions) keeping the bids secret is of primary importance, so that neither another bidder nor any other party can learn anything about them. Only a trusted auctioneer should learn the bids to the extent necessary for evaluating the auction. For moving the auction to a blockchain, the functions of the auctioneer are implemented by a smart contract. The distributed ledger stores encrypted bids such that the bidders are able to verify that their submitted bids were actually considered in the final evaluation. The blockchain nodes execute the auction’s smart contract, which records the bids, closes the auction, evaluates it, and autonomously executes the transaction assigning the item to the winning bidder and transferring the payment to the seller. 

By running the auction’s code within an SGX enclave, the auction maintains privacy and simultaneously benefits from the transparency of the blockchain. More precisely, the bids are encrypted, the key to decrypt them resides only inside the enclave, and the smart contract controls operations with the key. The bidders commit their encrypted bids to the blockchain and the enclave decrypts them for determining the winner. However, this simplistic auction solution may leak information, as described next, whenever a malicious node can manipulate the operation invocation order. 

State continuity and rollback attacks. As the industry is slowly realizing, rollback attacks on stateful applications running in TEEs pose serious risks, unless the state continuity of an application is ensured [9, 30, 37, 42, 43]. For instance, if a malicious blockchain node may influence the order in which transactions are executed by the enclave, the node can break the confidentiality of the sealed-bid auction even if it cannot decrypt the bids. In particular, the node 

might cause the enclave to execute the evaluation transaction multiple times and reset the enclave again afterwards, every time when a new bid has been stored on the blockchain. Thereby the node could learn information about other bids. This illustrates how an integrity violation can lead to breaking confidentiality. (Although platforms like SGX provide access to non-volatile monotonic counters that might prevent rollback attacks, their use introduces considerable complications for tolerating crashes and they are often too slow [9, 37]. Hence, we do not consider them in this work.) 

Rollback attacks can be prevented if the state input to the smart- contract enclave always corresponds to the unique, committed blockchain state. One way to guarantee the desired state continuity would be to run the whole blockchain node, especially its protocol logic and the state maintenance, within the enclave. This is often not feasible for practical reasons, however, and leads to other security issues because the code running inside the TEE has a large attack surface. However, in blockchain systems with non-final consensus protocols that may fork temporarily, a node remains prone to being rolled back by design, even when it resides completely in a TEE, because the underlying consensus protocol requires it. 

`Contributions`. In this paper we examine the state-continuity problem for trusted execution on blockchains, arising from roll- back attacks that malicious nodes might mount. We discuss why blockchains with consensus that has no final decisions, such as the “proof of work” in Bitcoin or Ethereum, are inherently unable to benefit from TEEs to maintain confidentiality. If the blockchain nodes hosting TEEs can access the final blockchain state in a trusted way, on the other hand, then such rollbacks can be prevented. 

As the main contribution of this work, we design a secure solution for secure smart-contract execution on a blockchain using Intel SGX, the most prominent TEE technology available today, and Hyperledger Fabric [3], or Fabric for short, a flexible and modular platform for consortium blockchains. Fabric uses a modular notion of consensus whose outputs are always final, which avoids the protocol-inherent rollback attack. As Fabric is the most prominent technology for consortium blockchains today, our design can also be integrated with other, similar systems. 

Some consortium blockchain platforms follow the generic approach to state-machine replication [38], where a consensus protocol first decides on an order among all transactions and the nodes subsequently execute them according to the decided order. In Fabric, however, the peers execute transactions and compute state updates before their relative order has been determined through a consensus protocol. The ordering process only uses the outcome of the transaction (i.e., the induced state changes) during consensus. While this offers a flexible programming model for smart contracts [3], it also introduces additional complications that must be considered. 

We have implemented a prototype that enables smart-contract execution inside Intel SGX for Hyperledger Fabric. We demonstrate an auction application and evaluate the performance of the prototype compared to the unprotected execution. The results show that our prototype reaches 0.80x–0.90x the throughput of the unprotected implementation, which is acceptable for protecting the confidentiality. 

Organization. This paper is structured as follows. In Section 2 we discuss why public blockchains with non-final consensus are 

inherently unable to execute smart contracts in TEEs. Section 3 introduces Intel SGX and Fabric, the two technologies used mostly in the remainder of the paper. In Section 4 we introduce the system model, describe the security goals, and discuss several approaches to run smart contracts in TEEs and their complications. Our solution to execute applications on Fabric with SGX is presented in Section 5 and its security is examined in Section 6. Performance evaluation results are reported in Section 7. Finally, Section 8 reviews related work and Section 9 concludes the paper. 

### 2 CONSENSUS WITH NON-FINAL DECISIONS 

Public blockchains patterned after Bitcoin [35] do not reach con- sensus with finality. Their consensus mechanism is based on a randomized protocol, in which for each epoch (or “block height”) a node selected through a probabilistic scheme that is difficult to bias (such as a “proof of work”) disseminates a block of transactions to be appended to the blockchain. Such blocks are propagated to all nodes with a peer-to-peer gossip protocol that is efficient but does not guarantee strict consistency. During regular operation, the view of the nodes in different parts of the network may di- verge, and such forks are resolved through the protocol rule that the “longest” branch is adopted by all nodes as the valid blockchain and determines the state. As shown by multiple formal analyses of the protocol (e.g., [15]), the probability that such forks last for many epochs vanishes exponentially fast, but it cannot be made negligible for short forks. If the underlying network does not ensure universal connectivity, this can lead to devastating attacks on the safety of a public blockchain [4]. 

When a node first receives the block as a candidate that should extend the current chain, the node validates the block’s content, including that all transactions inside are correct. For Bitcoin this validation is simply checking that a “coin state” has not been spent earlier, but for programmable blockchains like Ethereum [45], this entails executing all transactions and computing the correspond- ing state updates. If the block is valid, the node appends the block to its local chain and updates its state accordingly. But when the node later receives other blocks that are all valid and collectively extend a prefix of the currently held chain to a “longer” chain, the node reverts the earlier transactions and instead executes the sub- sequently received transactions. There is a significant probability that a node has to revert transactions during regular operation and, therefore, consensus is never final. In essence, a node must continue to participate in the consensus protocol forever, just to be sure that the blockchain state it holds remains valid. Blockchains using “proof-of-stake” consensus also suffer from similar forks (see the overview and analysis by David et al. [14]). 

As becomes clear from this discussion, TEEs cannot be used to secure transaction execution and validation in blockchains based on non-final consensus. For example, an Ethereum virtual machine (EVM) running within SGX would have to produce the outputs resulting from a transaction immediately, but already during normal operation, the EVM could be rolled back to an earlier state that is beyond its control. This also holds if the consensus protocol is executed inside the TEE, as a malicious host controlling the communication could censor blocks from the network and forge valid blocks of its choice, given enough time. As argued before 

through the auction example, application-level secrets could be revealed easily. 

Therefore consensus with finality seems to be a necessary pre- requisite to rely on TEEs for securing blockchains and for keeping transaction data secret. If one lets the TEE execute only trans- actions that are final, any attempt to roll back its state amounts to an attack, and such attacks can be prevented using existing methods for state continuity. This insight stands also behind some of the early designs and technologies that aim at this goal. For example, Microsoft’s Coco Framework [32], available only as a white paper so far, uses the EVM but mentions quorum-ba21sed consensus with finality. In the Hyperledger Sawtooth platform (http://www.hyperledger.org/projects/sawtooth), which is most ac- tively developed by Intel, the role of SGX technology lies in securing the “proof-of-elapsed-time (PoET)” consensus protocol, but SGX is not used for safeguarding secrets of a smart contract. 

### 3 TECHNOLOGIES 

In this section we review Hyperledger Fabric, an open-source blockchain platform developed under the Hyperledger Project (http: //www.hyperledger.org) hosted by the Linux Foundation. We then describe Intel’s Software Guard Extensions (SGX), which adds hardware-enforced security to the Intel CPU architecture and enables secure smart contract execution. 

#### 3.1 Hyperledger Fabric 

Hyperledger Fabric [3] is a permissioned blockchain platform (run by a consortium), where multiple parties may participate and to- gether form a distributed ledger network. The ledger records all interactions between the parties as transactions. A transaction invokes a smart contract called chaincode, which defines an appli- cation running on the blockchain. 

A Fabric network consists of clients, peers, and an ordering service, as illustrated in Fig. 1. For each peer, a special client called admin has administrative control over the peer, for instance in order to install a chaincode. The basic transaction flow is as follows: (1) A client invokes a chaincode by sending a transaction proposal to one or more peers, which (2) execute the chaincode and produce a proposal response called endorsement. (3) The client then collects the endorsements and assembles them to a transaction that it submits to the ordering service. (4) The ordering service establishes the total order of all transactions and broadcasts them as blocks of transactions to all peers in the network. When a peer receives a block, it validates every transaction, eliminates those that were based on state that has become invalid, and commits the valid ones to its local ledger. 

Other blockchain platforms execute transactions after ordering them [13], e.g., JPMC Quorum (https://github.com/jpmorganchase/ quorum), Hyperledger Sawtooth (https://github.com/hyperledger/ sawtooth-core), or Chain Core (https://chain.com/). In contrast, Fabric uses a three-phase execute-order-validate architecture. In the remainder of this section we provide more details of each phase. 

Chaincode execution and endorsement. A transaction of a chain- code is executed by a set of endorsing peers for the chaincode during the endorsement phase. Initially the chaincode is installed on every endorsing peer by an admin. The clients invoke the chaincode by 

3) Submit tx 

2) Proposal 1) Invoke tx response 

Ordering service 

sending a transaction proposal containing a chaincode operation to the peer. The chaincode takes the operation as input, processes it according to its smart-contract application, and may return an optional execution result. 

While executing, the chaincode may access the blockchain state, which is provided as a key-value store (KVS), with getState and putState operations. The putState operation does not immediately update the peers’ local state; instead, it records the change in a writeset, containing the updated keys and their values. Additionally, all keys accessed by the transaction during execution and their versions (i.e., the positions in the history where they were last updated) are collected in a so-called readset. 

Taken together, the execution result, the readset, and the write- set form a transaction proposal response or endorsement. The peer returns this to the client. Through executing the chaincode and producing the endorsement, the peer vouches for the correct exe- cution of the chaincode and endorses the change. An endorsement policy specifies the endorsing rules for each chaincode (e.g., who are the endorsing peers or how many endorsements are needed). Accordingly, the client collects sufficiently many endorsements and integrates them to a transaction that it submits for ordering. 

Ordering. The ordering service in Fabric is responsible for establishing the total order of all transactions in the blockchain and therefore to ensure a consistent view of all transactions across all peers. Typically, the ordering service consists of multiple nodes for scalability and resilience, and leverages a protocol to reach consen- sus on the total order. Clients submit transactions created in the endorsement phase to the ordering service. For efficiency, transactions are distributed among all peers in batches or blocks, using a gossip protocol [6]. 

Validation and state updates. A peer receives a block of trans- actions from the ordering service and utilizes a validation system chaincode (VSCC) to validate each transaction and apply its effects to the local ledger. Validation is a deterministic process and per- formed by every peer. In particular, the peer checks that every transaction fulfills the endorsement policy. Then, a read-write con- flict check is performed, that is, the peer verifies that the versions in the readset match the current blockchain state at the peer. If both validation checks are successful, the updates in the writeset of the transaction are applied to local blockchain state of the peer. An invalid transaction has no effect on the state and the issuing client should reinvoke the transaction again. A Fabric blockchain is initialized through a so-called `genesis` block, which is created collaboratively by all network participants. 

#### 3.2 Trusted execution with Intel SGX 

Modern trusted execution environments (TEEs), such as Intel’s Soft- ware Guard Extensions (SGX) [2, 18, 31], add hardware-enforced security to commodity platforms. SGX enables Fabric peers to execute chaincode in a trusted execution context, also called enclave. Particularly, an enclave defines an isolated memory area that is guarded by hardware-enforced mechanisms, which guarantee confidentiality and integrity of an enclave even if the entire platform is compromised. That is, even higher-privileged code (e.g., the operating system) can neither access that memory area nor modify it without being detected. 

Enclave protection and attestation. SGX enforces that only genuine applications are executed in an enclave. “Genuine” means that the code has not been tampered with and operates precisely as intended by the developer. For this reason, a cryptographic hash called `mrenclave` of the code and data initially loaded into the enclave is generated by the CPU. If mrenclave matches the hash of the genuine application signed by the developer, the enclave starts successfully. This ensures that the correct application (e.g., a specific chaincode) is runs in an enclave. 

During runtime, an enclave is capable to prove to a third party (e.g., a Fabric client or another peer) that a specific application is loaded and executed in an actual enclave on a SGX platform. For this purpose a procedure called remote attestation [2] is used. It works as follows: A client with prior information about mrenclave of the target enclave sends an attestation challenge to the enclave host (e.g., the peer) and in return receives a proof φ, also known as quote, produced by a target enclave and the platform. We use the term attestation report to refer to a quote. The client forwards φ to the Intel Attestation Service (IAS), which verifies it using a group signature scheme called EPID [12], and replies with an attestation result. The attestation result either confirms that φ was actually produced by an SGX enclave running the intended code or indicates that φ is invalid. The enclave can also embed custom data in φ, which builds the basis for key exchange protocols. 

Remote attestation involves an intermediate step called local attestation that is performed between two enclaves on the same platform. In this step, a special enclave called Quoting Enclave (QE) verifies that φ was produced by an enclave on the same platform, using HMAC with a shared secret key only accessible by enclaves on the same platform. Local attestation can be performed by any two enclaves on the same platform. 

Enclave state and data sealing. Since enclaves reside in a protected memory area in the CPU, enclaves are volatile, thus, when an enclave stops, restarts, or just crashes, its internal state is lost and cannot be recovered. For this reason SGX supports data sealing, a mechanism that allows to encrypt and authenticate data before it leaves an enclave and is stored externally (e.g., on persistent storage). After an enclave restarts, it may load the sealed data and decrypt it. Although the sealing mechanism protects data confidentiality, it does not prevent rollback attacks, that is, an attacker may cause an enclave to recover from properly sealed but stale data [9, 30, 43]. For many applications this poses serious problems and they must be protect against it, however, for stateless applications, such as chaincodes, this is not relevant. 

Moreover, enclaves have access to a secure random number generator that allows to build cryptographic primitives, such as key generation, encryption, and digital signatures. Both, remote attestation and data sealing rely on a cryptographic key-management infrastructure rooted in a secret key fused into the CPU, which provides deterministic key-derivation functions to an enclave.

### 4 PROBLEM DESCRIPTION 

This section describes the problem of secure smart-contract execution using trusted hardware for blockchains with final consensus, in particular, Hyperledger Fabric [3]. We explore intricacies that may still be caused by rollback attacks in this setting, illustrate a strawman approach that is infeasible, and introduce our approach to support secure chaincode execution using Intel SGX. This executes each chaincode in its own enclave during endorsement at a peer and thereby protects the confidentiality and integrity of the blockchain application. 

#### 4.1 System model 

We consider a Fabric blockchain network with clients, an ordering service, and a set of peers, which collaboratively execute transac- tions and maintain a distributed ledger on a single Fabric “channel.” 

A client invokes transactions by sending a chaincode operation to some peer, which then executes (simulates) it and produces an endorsement containing the resulting state change on the ledger. The operation, the response, as well as the ledger may contain sensitive information that should stay secret. 

To prevent such information leakage, every peer is equipped with an SGX-enabled CPU and executes transactions inside an enclave. The chaincode is stateless, and a transaction only takes the operation and the blockchain state in the KVS as inputs, accessed with getState. The chaincode must perform updates to the ledger only through putState operations. The execution of a chaincode operation returns a response that may include a computation result, the state update, and the read-write dependencies. 

#### 4.2 Threats 

Although most peers are usually correct, a peer may become mali- cious and behave incorrectly, for instance, when it tries to maximize its own profit or becomes corrupted by an attacker. A peer has full control over the operating system, applications, and the data resid- ing in memory and persistent storage (i.e., the blockchain state). A malicious peer, however, cannot access or tamper with the code and data residing in an enclave (see Section 3.2). A malicious peer may neither break cryptographic primitives nor extract any secret infor- mation that from an enclave. Consequently, a chaincode running in an enclave always produces the correct results, that is, the chain- code does not deviate from its specification, the enclave-internal state is only known to the enclave itself, and nothing is revealed apart from the resulting state change. 

However, a malicious peer can invoke the chaincode enclave with any input and in arbitrary order. The peer may intercept, modify, reorder, discard, or replay chaincode operations, and when the chaincode enclave accesses the KVS, the peer may feed any blockchain state to it. 

Furthermore, the peer might even drop messages or completely halt an enclave, but we do not consider such denial-of-service at- tacks in this work. We also ignore potential information leakage from SGX on side channels [10, 39, 41, 46] because this appears orthogonal to our focus. 

As is well-known from the literature on secure computation with cryptographic protocols [1], integrity and confidentiality cannot be considered separately. Likewise, for a secure application running in an enclave, a malicious host may break confidentiality by triggering the enclave to execute on “incorrect” inputs. In the blockchain context, this means that the chaincode execution deviates from the consensus-based transaction order. 

Repeating and extending the auction example from the intro- duction, such an attack could reveal secret information as follows. Suppose that evaluating the auction on the current blockchain state s1 would let a bid b1 win the auction. If the malicious node can trigger the auction-evaluation transaction, it learns b1. If the node can reset the enclave to s1 and execute another transaction, it can submit a bid b2, add it to the ledger, subsequently evaluate the auc- tion, and learn if b2 > b1. Such a rollback attack clearly breaks the confidentiality of the individual bids. As mentioned earlier, rollback attacks on trusted execution environments and their prevention has only recently been understood better [9, 30, 43]. 

4.3 Strawman approach 

It follows from the discussion in Section 2 that letting the enclave only execute transactions that have been ordered by the network with finality prevents the rollback problem. This amounts to run- ning the entire blockchain peer inside an enclave, as also suggested by Microsoft Coco [32, 40] and related work. We call this the straw- man approach that might work for an order-execute architecture where the consensus process has only final decisions, but we argue later why better designs exist. 

For Fabric, the strawman design would mean to encapsulate the chaincode execution, endorser, committer, ledger-state access, and all other parts of a peer inside an enclave. This obviously protects the integrity of the input sequence for the chaincode, since the entire Fabric peer runs within SGX. A similar approach is taken in the blockchain-as-a-service platform of IBM, which deploys Fabric peer as a secure service container on an IBM Z system. The secure container includes the whole operating system, middleware stack, and blockchain platform [19]. 

Although no operating system is running within SGX, recent research has demonstrated how legacy applications can run in SGX through a library OS that executes unmodified applications in an enclave [5, 7, 44]. Note that the library OS adds tens of thousands of lines of code that also run along the application in the enclave. 

This approach introduces multiple problems, however. First, it stands in contrast to the important computer-security principle of minimizing the size of the trusted computing base (TCB). Specifically, also the SGX developer guidelines [21] recommend to partition an application into a trusted and an untrusted component; only a small portion of the application code should execute inside the enclave. A smaller TCB has fewer errors, reduces the attack surface, and is more amenable to security analysis than the entire application. 

A second problem stems from the limited memory available to enclaves. An enclave’s memory resides in the enclave page cache (EPC) isolated from the rest of the system. The EPC is currently limited to 128 MB. Once an enclave reaches that limit pages are outsourced to DRAM. This results in a dramatic loss of performance, as reported in several works [5, 11, 36]. In particular, since the ledger grows with every block, holding the whole blockchain state in the enclave quickly reaches the memory limitation. 

4.4 Approach for Hyperledger Fabric 

To avoid the drawbacks of the strawman approach, we adopt a modular architecture that separates the chaincode execution con- ceptually from the peer and moves the execution into an enclave. The protocol-specific aspects of the peer are encapsulated in an abstract ordering service, of which one process might run on the same peer. The ordering service is trusted in the sense that it cannot be rolled back. 

The ordering service produces a signed sequence of transac- tions for execution within the enclave. The enclave can verify that transactions originate from the ordering service, are in the proper order, and have not been tampered with. The enclave also keeps information about the transaction history, which allows to detect transaction-ordering violations or replayed transactions. The ma- licious host might still reset the enclave to an earlier point in the execution sequence, but this would not harm the application since the transactions are deterministic and execution would simply pro- duce the same outputs again. 

As described so far, this approach works fine with an order- execute architecture for state-machine replication. Fabric, however, uses the execute-order-validate paradigm, where a peer executes a transaction before consensus on the order is reached (see Sec. 3.1). Consequently the execution is speculative and can be repeated without affecting the blockchain state, as transactions are simulated during endorsement and only take effect after the ordering. This means a malicious host could infer information about the secret application data from the speculative execution. Not even a trusted ordering service can prevent this type of leakage. 

To resolve this issue, we will have to adapt the applications to respect the speculative nature of execution in Fabric. For the auction example, in particular, a barrier will be stored on the blockchain such that the chaincode enclave only evaluates the auction if the barrier is present. The barrier is set by invoking the chaincode with a transaction to “close” the auction but not yet evaluate it. If the barrier is present on the ledger, a malicious peer may no longer submit new bids to the auction. On the other hand, the auction evaluation will only consider bids added to the ledger before the barrier. Note that this barrier plays a role similar to a memory barrier in a multi-core computer system with concurrent threads. 

Following the execute-order-validate architecture, the chain- code enclave must execute transactions only on the committed blockchain state, that is, with ledger entries that result from ordered transactions and that have been committed by all peers. Otherwise a malicious peer may produce the barrier itself and feed the result- ing state into the enclave when evaluating the auction. The system described in the next section ensures this. 

To formally model the information leakage permitted in the execute-order-validate architecture of Fabric, we model a blockchain 